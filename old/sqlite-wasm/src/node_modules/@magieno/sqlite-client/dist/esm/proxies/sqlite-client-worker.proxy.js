import { SqliteClientTypeEnum } from "../enums/sqlite-client-type.enum";
import { CreateDatabaseMessage } from "../messages/create-database.message";
import { ExecuteSqlMessage } from "../messages/execute-sql.message";
import { SqliteMessageTypeEnum } from "../enums/sqlite-message-type.enum";
export class SqliteClientWorkerProxy {
    constructor(options) {
        this.options = options;
        this.queuedPromises = {};
    }
    init() {
        const createDatabaseMessage = new CreateDatabaseMessage(this.options);
        const promise = new Promise((resolve, reject) => {
            this.queuedPromises[createDatabaseMessage.uniqueId] = {
                resolve,
                reject,
            };
        });
        if (this.options.type === SqliteClientTypeEnum.MemoryMainThread || !("sqliteWorkerPath" in this.options)) {
            throw new Error(`The Sqlite-Client-Worker does not support the [${SqliteClientTypeEnum.MemoryMainThread}] types. This type can be used directly in the main thread.`);
        }
        this.worker = new Worker(this.options.sqliteWorkerPath, {
            type: "module",
        });
        this.worker.onmessage = this.messageReceived.bind(this);
        this.worker.postMessage(createDatabaseMessage);
        return promise;
    }
    messageReceived(message) {
        const sqliteMessage = message.data;
        if (sqliteMessage.uniqueId !== undefined && this.queuedPromises.hasOwnProperty(sqliteMessage.uniqueId)) {
            const promise = this.queuedPromises[sqliteMessage.uniqueId];
            delete this.queuedPromises[sqliteMessage.uniqueId];
            switch (sqliteMessage.type) {
                case SqliteMessageTypeEnum.ExecuteSqlResult:
                    const executeSqlResultMessage = sqliteMessage;
                    if (executeSqlResultMessage.error) {
                        return promise.reject(executeSqlResultMessage.error);
                    }
                    return promise.resolve(executeSqlResultMessage.result);
                case SqliteMessageTypeEnum.CreateDatabaseResult:
                    const createDatabaseResultMessage = sqliteMessage;
                    if (createDatabaseResultMessage.error) {
                        return promise.reject(createDatabaseResultMessage.error);
                    }
                    return promise.resolve();
            }
        }
    }
    executeSql(sqlStatement, bindParameters, returnValue, rowMode) {
        const executeSqlMessage = new ExecuteSqlMessage(sqlStatement, bindParameters, returnValue, rowMode);
        const promise = new Promise((resolve, reject) => {
            this.queuedPromises[executeSqlMessage.uniqueId] = {
                resolve,
                reject,
            };
        });
        this.worker.postMessage(executeSqlMessage);
        return promise;
    }
}
//# sourceMappingURL=sqlite-client-worker.proxy.js.map