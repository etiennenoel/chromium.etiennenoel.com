var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SqliteMessageTypeEnum } from "./enums/sqlite-message-type.enum";
import { CreateDatabaseResultMessage } from "./messages/create-database-result.message";
import { default as sqlite3InitModule } from "@sqlite.org/sqlite-wasm";
import { ExecuteSqlResultMessage } from "./messages/execute-sql-result.message";
import { SqliteClientTypeEnum } from "./enums/sqlite-client-type.enum";
const log = (...args) => console.log(...args);
class SqliteClientWorker {
    constructor() {
    }
    onMessageReceivedFromMainThread(messageEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            const sqliteMessage = messageEvent.data;
            switch (sqliteMessage.type) {
                case SqliteMessageTypeEnum.CreateDatabase:
                    yield this.createDatabase(sqliteMessage);
                    break;
                case SqliteMessageTypeEnum.ExecuteSql:
                    this.executeSql(sqliteMessage);
                    break;
            }
        });
    }
    postBackMessageToMainThread(message) {
        self.postMessage(message);
    }
    createDatabase(createDatabaseMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            const uniqueId = createDatabaseMessage.uniqueId;
            const errorHandler = (error) => {
                console.error(error);
                this.postBackMessageToMainThread(new CreateDatabaseResultMessage(uniqueId, error));
                return;
            };
            try {
                const sqlite3 = yield sqlite3InitModule({
                    print: log,
                    printErr: errorHandler,
                });
                switch (createDatabaseMessage.options.type) {
                    case SqliteClientTypeEnum.MemoryMainThread:
                        this.postBackMessageToMainThread(new CreateDatabaseResultMessage(createDatabaseMessage.uniqueId, new Error(`The Sqlite-Client-Worker does not support the [${SqliteClientTypeEnum.MemoryMainThread}] types. This type can be used directly in the main thread.`)));
                        break;
                    case SqliteClientTypeEnum.MemoryWorker:
                        try {
                            const options = createDatabaseMessage.options;
                            this.db = new sqlite3.oo1.DB(options.filename, options.flags);
                            this.postBackMessageToMainThread(new CreateDatabaseResultMessage(uniqueId));
                        }
                        catch (err) {
                            errorHandler(err);
                        }
                        break;
                    case SqliteClientTypeEnum.OpfsWorker:
                        try {
                            const options = createDatabaseMessage.options;
                            this.db = new sqlite3.oo1.OpfsDb(options.filename, options.flags);
                            this.postBackMessageToMainThread(new CreateDatabaseResultMessage(uniqueId));
                        }
                        catch (err) {
                            errorHandler(err);
                        }
                        break;
                    case SqliteClientTypeEnum.OpfsSahWorker:
                        try {
                            const options = createDatabaseMessage.options;
                            const poolUtil = yield sqlite3.installOpfsSAHPoolVfs({
                                name: createDatabaseMessage.options.name,
                                directory: createDatabaseMessage.options.directory,
                                clearOnInit: createDatabaseMessage.options.clearOnInit,
                            });
                            this.db = new poolUtil.OpfsSAHPoolDb(createDatabaseMessage.options.filename);
                            this.postBackMessageToMainThread(new CreateDatabaseResultMessage(uniqueId));
                        }
                        catch (err) {
                            errorHandler(err);
                        }
                        break;
                }
            }
            catch (err) {
                errorHandler(err);
            }
        });
    }
    executeSql(executeSqlMessage) {
        if (!this.db) {
            this.postBackMessageToMainThread(new ExecuteSqlResultMessage(executeSqlMessage.uniqueId, [], new Error("The database has not been created yet. Send a CreateDatabaseMessage first.")));
            return;
        }
        try {
            const result = this.db.exec({
                sql: executeSqlMessage.sqlStatement,
                bind: executeSqlMessage.bindingParameters,
                returnValue: executeSqlMessage.returnValue,
                rowMode: executeSqlMessage.rowMode,
            });
            this.postBackMessageToMainThread(new ExecuteSqlResultMessage(executeSqlMessage.uniqueId, result));
        }
        catch (e) {
            this.postBackMessageToMainThread(new ExecuteSqlResultMessage(executeSqlMessage.uniqueId, [], e));
        }
    }
}
const sqliteClientWorker = new SqliteClientWorker();
self.onmessage = (messageEvent) => __awaiter(void 0, void 0, void 0, function* () {
    yield sqliteClientWorker.onMessageReceivedFromMainThread(messageEvent);
});
//# sourceMappingURL=sqlite-client-worker.js.map